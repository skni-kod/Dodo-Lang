#ifndef BYTECODE_INTERNAL_HPP
#define BYTECODE_INTERNAL_HPP

#include <vector>
#include "Bytecode.hpp"

/// <summary>
/// Runs expression generation, intended to be used by outside calls
/// Contains check for type correctness
/// </summary>
/// <param name="context">Context</param>
/// <param name="values">Vector of parsed values</param>
/// <param name="expected">End type of expression to be generated, will throw an error if it can't be done</param>
/// <param name="isGlobal">Set to true if this call is generating in global context, limitations will be applied</param>
/// <param name="index">Index in value array to start at</param>
/// <returns>Operand with the result of operation</returns>
BytecodeOperand GenerateExpressionRunner(Context& context, std::vector<ParserTreeValue>& values, TypeInfo expected = {}, bool isGlobal = false, uint16_t index = 0);

/// <summary>
/// Checks if the actual type matches with the expected one and dereferences any references
/// </summary>
/// <param name="context">Context</param>
/// <param name="expected">Expected resulting type, if type is nullptr original operand is returned</param>
/// <param name="actual">Type that was found during the operation</param>
/// <param name="op">Operand that is the result of the operation</param>
/// <returns>The original operand or dereferenced reference</returns>
BytecodeOperand CheckCompatibilityAndConvertReference(Context& context, TypeInfo expected, TypeInfo actual, BytecodeOperand op);

/// <summary>
/// Generated bytecode from any valid parsed expression and returns the result
/// It's intended to be called via a runner function
/// </summary>
/// <param name="context">Context of operation</param>
/// <param name="values">Vector of values</param>
/// <param name="expected">Expected type at the end of expression</param>
/// <param name="actual">Actual type at given stage of expression</param>
/// <param name="index">Index in the values vector to start generation from</param>
/// <param name="isGlobal">Set to true if it's executed in global context</param>
/// <param name="passedOperand">Passed result operand from previous operation, for use with the next statement</param>
/// <returns>Resulting operand with value of the expression</returns>
BytecodeOperand GenerateExpressionBytecode(Context& context, std::vector<ParserTreeValue>& values, TypeInfo expected, TypeInfo& actual, uint16_t index = 0, bool isGlobal = false, BytecodeOperand passedOperand = {});

BytecodeOperand InsertOperatorExpression(Context& context, std::vector<ParserTreeValue>& values, TypeInfo expected, TypeInfo& actual, uint16_t index = 0, bool isGlobal = false, BytecodeOperand passedOperand = {});
bool AddCallIfMatches(Context& context, ParserFunctionMethod* called, std::vector<ParserTreeValue>& values, ParserTreeValue& node, std::vector<TypeInfo>& arguments, Bytecode& code, BytecodeOperand passedOperand, bool isGlobal);

void GetTypes(Context& context, std::vector<ParserTreeValue>& values, TypeInfo& result, uint16_t index);
void GetTypes(Context& context, std::vector<ParserTreeValue>& values, TypeInfo& result, ParserTreeValue& current);

#endif //BYTECODE_INTERNAL_HPP
