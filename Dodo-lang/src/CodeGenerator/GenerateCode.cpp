#include "GenerateCode.hpp"

#include <Assembly.hpp>
#include "Memory.hpp"

#include "Bytecode/Bytecode.hpp"
#include <filesystem>
#include <fstream>
#include <Increment.hpp>
#include <iostream>
#include <Lifetime.hpp>
#include <Parser.hpp>
#include <X86_64Config.hpp>

#include "Options.hpp"
#include "X86_64.hpp"

namespace fs = std::filesystem;

const char* __CodeGeneratorException::what() {
    return "Code generator has encountered unexpected input";
}

void CodeGeneratorError(std::string message) {
    std::cout << "ERROR! " << message << "\n";

    throw __CodeGeneratorException();
}

void Warning(std::string message) {
    std::cout << "WARNING: " << message << "\n";
}


void GenerateCode() {
    doneParsing = true;
    std::ofstream out;
    if (!fs::is_directory("build")) {
        fs::create_directory("build");
    }
    out.open("build/out.s");
    if (!out.is_open()) {
        CodeGeneratorError("Failed to create/open output assembly file");
    }

    // Code generation is done on a per-function basis to reduce peak memory usage, and there's no downsides I'm aware of

    Processor proc;

    // prepare structures here
    // TODO: make this a dedicated function probably
    if (Options::targetArchitecture == Options::TargetArchitecture::x86_64) {
        x86_64::PrepareProcessor(proc);

        Options::commentPrefix = "# ";
        Options::jumpLabelPrefix = ".LJ";
        out << Options::commentPrefix << "Generated by Dodo-Lang compiler\n";
        out << Options::commentPrefix << "Version: " << incrementedVersionValue << "\n";
        out << Options::commentPrefix << "Target architecture: x86-64\n";
        out << Options::commentPrefix << "Architecture version: ";
             if (Options::architectureVersion == Options::AMD64_v1) out << "x86-64_v1\n";
        else if (Options::architectureVersion == Options::AMD64_v2) out << "x86-64_v2\n";
        else if (Options::architectureVersion == Options::AMD64_v3) out << "x86-64_v3\n";
        else if (Options::architectureVersion == Options::AMD64_v4) out << "x86-64_v4\n";
        if (Options::targetSystem == "LINUX") {
            out << Options::commentPrefix << "Target system: Linux\n";
        }
        else if (Options::targetSystem == "WINDOWS") {
            CodeGeneratorError("Windows target is not supported due to different syscalls an the whole winapi mess!");
        }
        else {
            CodeGeneratorError("Invalid target system!");
        }
        out << ".section .data\n";
        // global variables
        //x86_64::AddGlobalVariables(out);

        out << "\n.section .text\n";
        // global text declaration

        for (uint64_t n = 0; n < passedStrings.size(); n++) {
            out << "LS" << std::to_string(n) << ":\n" << std::string(Options::functionIndentation, ' ') << ".string " << passedStrings[n] << "\n\n";
        }

        out << "\n.global _start\n";

        out << "\n"
            << "_start:\n";

        auto context = GenerateGlobalVariablesBytecode();

        if (Options::informationLevel >= Options::InformationLevel::general) {
            std::cout << "INFO L2: Finished global variable bytecode generation with " << context.codes.size() << " instructions";
            if (Options::informationLevel >= Options::InformationLevel::full) {
                std::cout << ":\n";
                for (auto& n : context.codes) {
                    std::cout << "INFO L3: " << n;
                }
            }
            else {
                std::cout << "\n";
            }
        }

        CalculateLifetimes(context);
        CalculateMemoryAssignments(proc, context);
        CalculateMemoryAssignments(proc, context);
        x86_64::ConvertBytecode(context, proc, nullptr, out);

        {
            if (not functions.contains("Main")) CodeGeneratorError("Function \"Main\" not found!");
            auto callMain = AsmInstruction(x86_64::call, {&functions["Main"]});
            x86_64::PrintInstruction(callMain, out);
        }
        //PrintWithSpaces("movq", out);
        //out << "%rax, %rdi\n";
        //PrintWithSpaces("movq", out);
        //out << "$60, %rax\n";
        //PrintWithSpaces("syscall", out);
        //out << "\n";
    }
    else {
        CodeGeneratorError("Invalid target architecture!");
    }

    // methods
    for (auto& n : types) {
        for (auto& m : n.second.methods) {
            auto context = GenerateFunctionBytecode(m);
            if (Options::informationLevel >= 2) {
                // TODO: add waaaay more printing functions
                std::cout << "INFO L3: Bytecodes for method <something>(...):\n";
                for (auto& k : context.codes) {
                    std::cout << "INFO L3: " << k;
                }
            }
            CalculateLifetimes(context);
            proc.clear();
            CalculateMemoryAssignments(proc, context);
            x86_64::ConvertBytecode(context, proc, &m, out);
        }
    }

    // functions
    for (auto& n : functions) {
        auto context = GenerateFunctionBytecode(n.second);
        if (Options::informationLevel >= 2) {
            // TODO: add waaaay more printing functions
            std::cout << "INFO L3: Bytecodes for function " << *n.second.name << "(...):\n";
            for (auto& k : context.codes) {
                std::cout << "INFO L3: " << k;
            }
        }
        CalculateLifetimes(context);
        proc.clear();
        CalculateMemoryAssignments(proc, context);
        auto label = AsmInstruction(x86_64::label, AsmOperand(&n.second));
        out << "\n";
        x86_64::PrintInstruction(label, out);
        x86_64::ConvertBytecode(context, proc, &n.second, out);
    }

    
    /*
    // Functions:
    for (auto& current: parserFunctions.map) {
        // cleaning up after possible previous thing
        bytecodes.clear();
        finalInstructions.clear();
        lastFunctionName = &current.second.name;
        generatorMemory.cleanX86_86();
        if (Options::targetArchitecture == Options::TargetArchitecture::x86_64) {
            out << "\n"
                << current.second.name << ":" << "\n";
            PrintWithSpaces("pushq", out);
            out << "%rbp\n";
            PrintWithSpaces("movq", out);
            out << "%rsp, %rbp\n";
        }

        // first off the instructions need to be changed into raw operations universal for platforms
        //GenerateFunctionStepOne(current.second);

        // general optimizations will take place here
        if (Optimizations::optimizeBytecode) {
            //OptimizeBytecode();
        }

        // next convert them into platform specific code
        //GenerateFunctionStepTwo(current.second);
        // platform specific optimizations will be done here

        // at the end use the calculated stack offset and put the thing into code
        //for (auto& finalInstruction: finalInstructions) {
        //    finalInstruction.outputX86_64(out);
        //}

        // end function
        if (Options::targetArchitecture == Options::TargetArchitecture::x86_64) {
            if (doAddLeave) {
                PrintWithSpaces("leave", out);
                out << "\n";
            }
            else {
                PrintWithSpaces("popq", out);
                out << "%rbp\n";
            }
            PrintWithSpaces("ret", out);
            out << "\n";
        }
        current.second.instructions.clear();
    }
    */
    // add end code here along with the runner code fragment
    if (Options::targetArchitecture == Options::TargetArchitecture::x86_64) {

    }

    std::cout << "INFO L1: Assembly output generation complete!\n";
}
