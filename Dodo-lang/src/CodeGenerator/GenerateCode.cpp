#include "GenerateCode.hpp"

#include <Assembly.hpp>

#include "Bytecode/Bytecode.hpp"
#include <filesystem>
#include <fstream>
#include <Increment.hpp>
#include <iostream>
#include <Lifetime.hpp>
#include <Parser.hpp>
#include <X86_64Config.hpp>
#include <X86_64Enums.hpp>

#include "ErrorHandling.hpp"
#include "Options.hpp"
#include "X86_64.hpp"

namespace fs = std::filesystem;

const char* __CodeGeneratorException::what() {
    return "Code generator has encountered unexpected input";
}

void CodeGeneratorError(std::string message) {
    std::cout << "ERROR! " << message << "\n";

    throw __CodeGeneratorException();
}

void Warning(std::string message) {
    std::cout << "WARNING: " << message << (message.ends_with("!") ? "" : "!") << "\n";
}


void GenerateCode() {
    SetCompilationStage(CompilationStage::bytecode);

    doneParsing = true;
    std::ofstream out;
    if (!fs::is_directory("build")) {
        fs::create_directory("build");
    }
    out.open("build/out.s");
    if (!out.is_open()) {
        CodeGeneratorError("Failed to create/open output assembly file");
    }

    // Code generation is done on a per-function basis to reduce peak memory usage, and there's no downsides I'm aware of

    // prepare structures here
    // TODO: make this a dedicated function probably
    if (Options::targetArchitecture == Options::TargetArchitecture::x86_64) {
        Options::commentPrefix = "# ";
        Options::jumpLabelPrefix = ".LJ";
        out << Options::commentPrefix << "Generated by Dodo-Lang compiler\n";
        out << Options::commentPrefix << "Version: " << incrementedVersionValue << "\n";
        out << Options::commentPrefix << "Target architecture: x86-64\n";
        out << Options::commentPrefix << "Architecture version: ";
             if (Options::architectureVersion == Options::AMD64_v1) out << "x86-64_v1\n";
        else if (Options::architectureVersion == Options::AMD64_v2) out << "x86-64_v2\n";
        else if (Options::architectureVersion == Options::AMD64_v3) out << "x86-64_v3\n";
        else if (Options::architectureVersion == Options::AMD64_v4) out << "x86-64_v4\n";
        if (Options::targetSystem == TARGET_SYSTEM_LINUX) {
            out << Options::commentPrefix << "Target system: Linux\n";
        }
        else if (Options::targetSystem == TARGET_SYSTEM_WINDOWS) {
            CodeGeneratorError("Windows is not supported because I don't want to deal with their weird .dll's!");
        }
        else {
            CodeGeneratorError("Invalid target system!");
        }
        out << ".section .data\n";

        out << "\n.section .text\n";
        // global text data
        for (auto& n : passedStrings) {
            out << "LS" << std::to_string(n.second) << ":\n" << std::string(Options::functionIndentation, ' ') << ".string \"" << n.first << "\"\n";
        }
        for (auto& n : passedLongStrings) {
            out << "LS" << std::to_string(n.second) << ":\n" << std::string(Options::functionIndentation, ' ') << ".string \"" << *n.first << "\"\n";
        }

        out << "\n.global _start\n";

        out << "\n"
            << "_start:\n";

        auto context = GenerateGlobalVariablesBytecode();
        x86_64::PrepareProcessor(context);

        if (Options::informationLevel >= Options::InformationLevel::general) {
            std::cout << "INFO L2: Finished global variable bytecode generation with " << context.codes.size() << " instructions";
            if (Options::informationLevel >= Options::InformationLevel::full) {
                std::cout << ":\n";
                for (uint64_t k = 0; k < context.codes.size(); k++) {
                    std::cout << "INFO L3: (" << k << ") " << context.codes[k];
                }
            }
            else {
                std::cout << "\n";
            }
        }

        CalculateLifetimes(context);
        SetCompilationStage(CompilationStage::assembly);
        x86_64::ConvertBytecode(context, nullptr, out);
        SetCompilationStage(CompilationStage::output);

        if (not functions.contains("Main")) CodeGeneratorError("Function \"Main\" not found!");
        x86_64::PrintInstruction(out, {x86_64::call, {&functions["Main"][0]}});



        x86_64::PrintInstruction(out, {x86_64::mov,
            AsmOperand(Location::reg, Type::none, false, 8, x86_64::RDI),
            AsmOperand(Location::reg, Type::none, false, 8, x86_64::RAX)});
        
        x86_64::PrintInstruction(out, {x86_64::mov,
            AsmOperand(Location::reg, Type::none, false, 8, x86_64::RAX),
            AsmOperand(Location::imm, Type::unsignedInteger, false, 8, 60)});

        x86_64::PrintInstruction(out, {x86_64::syscall});
    }
    else {
        CodeGeneratorError("Invalid target architecture!");
    }

    // methods
    for (auto& n : types) {
        for (auto& m : n.second.methods) {
            SetCompilationStage(CompilationStage::bytecode);

            auto context = GenerateFunctionBytecode(m);
            x86_64::PrepareProcessor(context);
            CalculateLifetimes(context);
            SetCompilationStage(CompilationStage::output);
            auto label = AsmInstruction(x86_64::label, AsmOperand(&m));
            out << "\n";
            x86_64::PrintInstruction(label, out);
            SetCompilationStage(CompilationStage::assembly);
            x86_64::ConvertBytecode(context, &m, out);
        }
    }

    // functions
    for (auto& n : functions) {
        for (auto& m : n.second) {
            if (m.isExtern) continue;

            SetCompilationStage(CompilationStage::bytecode);

            auto context = GenerateFunctionBytecode(m);
            x86_64::PrepareProcessor(context);
            CalculateLifetimes(context);
            SetCompilationStage(CompilationStage::output);
            auto label = AsmInstruction(x86_64::label, AsmOperand(&m));
            out << "\n";
            x86_64::PrintInstruction(label, out);
            SetCompilationStage(CompilationStage::assembly);
            x86_64::ConvertBytecode(context, &m, out);
        }
    }

    std::cout << "INFO L1: Assembly output generation complete!\n";
}
