#include "GenerateCode.hpp"
#include "GenerateCodeInternal.hpp"
#include "MemoryStructure.hpp"
#include "Bytecode/Bytecode.hpp"
#include "Assembly/X86_64/X86_64Assembly.hpp"
#include <filesystem>
#include <fstream>

#include "Options.hpp"

namespace fs = std::filesystem;

const char* __CodeGeneratorException::what() {
    return "Code generator has encountered unexpected input";
}

void CodeGeneratorError(std::string message) {
    if (currentlyGeneratedInstruction != nullptr) {
        std::cout << "ERROR! " << *currentlyGeneratedInstruction->sourceFile << " at line : "
                  << currentlyGeneratedInstruction->sourceLine + 1 << " : " << message << "\n";
    }
    else {
        std::cout << "ERROR! " << message << "\n";
    }

    throw __CodeGeneratorException();
}

void Warning(std::string message) {
    std::cout << "WARNING: " << message << "\n";
}



void GenerateCode() {
    doneParsing = true;
    std::ofstream out;
    if (!fs::is_directory("build")) {
        fs::create_directory("build");
    }
    out.open("build/out.s");
    if (!out.is_open()) {
        CodeGeneratorError("Failed to create/open output assembly file");
    }

    // Code generation is done on a per-function basis to reduce peak memory usage, and there's no downsides I'm aware of

    // prepare structures here
    // TODO: make this a dedicated function probably
    if (Options::targetArchitecture == Options::TargetArchitecture::x86_64) {
        generatorMemory.prepareX86_86();
        Options::commentPrefix = "# ";
        Options::jumpLabelPrefix = ".LJ";
        out << Options::commentPrefix << "Generated by Dodo-Lang compiler\n";
        out << Options::commentPrefix << "Target architecture: X86_64\n";
        if (Options::targetSystem == "LINUX") {
            out << Options::commentPrefix << "Target system: LINUX\n";
        }
        else if (Options::targetSystem == "WINDOWS") {
            CodeGeneratorError("Windows target is not supported!");
        }
        else {
            CodeGeneratorError("Invalid target system!");
        }
        out << ".section .data\n";
        // global variables
        //x86_64::AddGlobalVariables(out);
        auto globalBytecode = GenerateGlobalVariablesBytecode();

        if (Options::informationLevel >= Options::InformationLevel::general) {
            std::cout << "INFO L2: Finished global variable bytecode generation with " << globalBytecode.size() << " instructions";
            if (Options::informationLevel >= Options::InformationLevel::full) {
                std::cout << ":\n";
                for (auto& n : globalBytecode) {
                    std::cout << "INFO L3: " << n;
                }
            }
            else {
                std::cout << "\n";
            }
        }

        out << "\n.section .text\n";
        // global text declaration

        for (uint64_t n = 0; n < passedStrings.size(); n++) {
            out << "\nLS" << n << ":\n";
            PrintWithSpaces(".ascii", out);
            out << " " << passedStrings[n] << "\n";
        }
        
        out << "\n.global _start\n";
    }
    else {
        CodeGeneratorError("Invalid target architecture!");
    }

    // put beginning things here, like message declaration
    
    
    
    /*
    // Functions:
    for (auto& current: parserFunctions.map) {
        // cleaning up after possible previous thing
        bytecodes.clear();
        finalInstructions.clear();
        lastFunctionName = &current.second.name;
        generatorMemory.cleanX86_86();
        if (Options::targetArchitecture == Options::TargetArchitecture::x86_64) {
            out << "\n"
                << current.second.name << ":" << "\n";
            PrintWithSpaces("pushq", out);
            out << "%rbp\n";
            PrintWithSpaces("movq", out);
            out << "%rsp, %rbp\n";
        }

        // first off the instructions need to be changed into raw operations universal for platforms
        //GenerateFunctionStepOne(current.second);

        // general optimizations will take place here
        if (Optimizations::optimizeBytecode) {
            //OptimizeBytecode();
        }

        // next convert them into platform specific code
        //GenerateFunctionStepTwo(current.second);
        // platform specific optimizations will be done here

        // at the end use the calculated stack offset and put the thing into code
        //for (auto& finalInstruction: finalInstructions) {
        //    finalInstruction.outputX86_64(out);
        //}

        // end function
        if (Options::targetArchitecture == Options::TargetArchitecture::x86_64) {
            if (doAddLeave) {
                PrintWithSpaces("leave", out);
                out << "\n";
            }
            else {
                PrintWithSpaces("popq", out);
                out << "%rbp\n";
            }
            PrintWithSpaces("ret", out);
            out << "\n";
        }
        current.second.instructions.clear();
    }
    */
    // add end code here along with the runner code fragment
    if (Options::targetArchitecture == Options::TargetArchitecture::x86_64) {
        out << "\n"
            << "_start:\n";
        PrintWithSpaces("call", out);
        out << "Main\n";
        PrintWithSpaces("movq", out);
        out << "%rax, %rdi\n";
        PrintWithSpaces("movq", out);
        out << "$60, %rax\n";
        PrintWithSpaces("syscall", out);
        out << "\n";
    }

    std::cout << "INFO L1: Assembly output generation complete!\n";
}
