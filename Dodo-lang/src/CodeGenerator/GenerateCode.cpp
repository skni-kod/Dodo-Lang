#include "GenerateCode.hpp"
#include "GenerateCodeInternal.hpp"
#include "MemoryStructure.hpp"
#include "Bytecode.hpp"
#include <filesystem>
#include <fstream>

namespace fs = std::filesystem;

const char* __CodeGeneratorException::what() {
    return "Code generator has encountered unexpected input";
}

void CodeGeneratorError(std::string message) {
    std::cout << "ERROR! " << message << "\n";
    throw __CodeGeneratorException();
}


void GenerateCode() {
    doneParsing = true;
    std::ofstream out;
    if (!fs::is_directory("build")) {
        fs::create_directory("build");
    }
    out.open("build/out.s");
    if (!out.is_open()) {
        CodeGeneratorError("Failed to create/open output assembly file");
    }

    // Code generation is done on a per-function basis to reduce peak memory usage, and there's no downsides I'm aware of

    // prepare structures here
    // TODO: make this a dedicated function probably
    if (options::targetArchitecture == "X86_64") {
        generatorMemory.prepareX86_86();
        options::commentPrefix = "# ";
        out << options::commentPrefix << "Generated by Dodo-Lang compiler by SKNI \"KOD\"\n";
        out << options::commentPrefix << "Target architecture: X86_64\n";
        if (options::targetSystem == "LINUX") {
            out << options::commentPrefix << "Target system: LINUX\n";
        }
        else if (options::targetSystem == "WINDOWS") {
            CodeGeneratorError("Windows target is not supported!");
        }
        else {
            CodeGeneratorError("Invalid target system!");
        }
        out << ".data\n"
            << ".text\n"
            << ".global _start\n";
    }
    else if (options::targetArchitecture == "X86_32") {
        CodeGeneratorError("X86-32 not yet supported!");
    }
    // might change arm names to versions when support comes
    else if (options::targetArchitecture == "ARM32") {
        CodeGeneratorError("ARM32 not yet supported!");
    }
    else if (options::targetArchitecture == "ARM64") {
        CodeGeneratorError("ARM64 not yet supported!");
    }
    else {
        CodeGeneratorError("Invalid target architecture!");
    }

    // put beginning things here, like message declaration

    // Functions:
    for (auto& current : parserFunctions.map) {
        // cleaning up after possible previous thing
        bytecodes.clear();
        if (options::targetArchitecture == "X86_64") {
            generatorMemory.cleanX86_86();
            out << "\n"
                << current.second.name << ":" << "\n"
                << "pushq   %rbp\n"
                << "movq    %rsp, %rbp\n";
        }

        // first off the instructions need to be changed into raw operations universal for platforms
        // general optimizations will take place here
        GenerateFunctionStepOne(current.second);

        // next convert them into platform specific code
        // platform specific optimizations will be done here

        // at the end use the calculated stack offset and put the thing into code


        // end function
        if (options::targetArchitecture == "X86_64") {
            out << "popq    %rbp\n"
                << "ret\n";
        }
    }
    // add end code here along with the runner code fragment
    if (options::targetArchitecture == "X86_64") {
        out << "\n"
            << "_start:\n"
            << "call    main\n"
            << "movq    %rax, %rdi\n"
            << "movq    $60, %rax\n"
            << "syscall\n";
    }
}

std::ostream& operator<<(std::ostream& out, const VariableType& type) {
    switch(type.subtype) {
        case VariableType::Subtype::value:
            out << "value of ";
            break;
        case VariableType::Subtype::reference:
            out << "reference to ";
            break;
        case VariableType::Subtype::pointer:
            out << "pointer to ";
            break;
        default:
            CodeGeneratorError("Invalid variable subtype!");
    }
    switch(type.type) {
        case ParserType::Type::unsignedInteger:
            out << "unsigned integer variable ";
            break;
        case ParserType::Type::signedInteger:
            out << "signed integer variable ";
            break;
        case ParserType::Type::floatingPoint:
            out << "floating point variable ";
            break;
        default:
            CodeGeneratorError("Invalid variable type!");
    }
    out << "sized " << uint64_t(type.size) << " bytes";
    return out;
}


VariableType::VariableType(uint8_t size, uint8_t type, uint8_t subtype) : size(size), type(type), subtype(subtype) {}

bool VariableType::operator==(const VariableType &var) {
    if (size == var.size and type == var.type and subtype == var.subtype) {
        return true;
    }
    return false;
}
